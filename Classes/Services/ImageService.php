<?php

namespace W4Services\W4Cloudinary\Services;

use TYPO3\CMS\Core\Resource\FileInterface;
use TYPO3\CMS\Core\Resource\FileReference;
use TYPO3\CMS\Core\Resource\ProcessedFile;
use TYPO3\CMS\Extbase\Service\ImageService as Typo3ImageService;

use W4Services\W4Cloudinary\Constants;
use W4Services\W4Cloudinary\Traits\Configuration;

class ImageService extends Typo3ImageService {

    use Configuration;

    /** @var array */
    private $processingInstructions;

    public function applyProcessingInstructions($image, array $processingInstructions): ProcessedFile {
        if(
            !$this->canDeliverViaCloudinary( $image, $processingInstructions)
         || $this->excludedByIp()
        ) {
            return parent::applyProcessingInstructions(
                $image,
                $processingInstructions
            );
        }

        $this->processingInstructions = $processingInstructions;

        return new ProcessedFile(
            ($image instanceof FileReference)
                ? $image->getOriginalFile()
                : $image,
            ProcessedFile::CONTEXT_IMAGECROPSCALEMASK,
            []
        );
    }

    public function getImageUri( FileInterface $image, $absolute = false): string {
        $processingInstructions = $image instanceof ProcessedFile && !empty($image->getProcessingConfiguration())
            ? $image->getProcessingConfiguration()
            : $this->processingInstructions;

        if(
            !$this->canDeliverViaCloudinary( $image, $processingInstructions)
         || $this->excludedByIp()
        ) {
            return parent::getImageUri(
                $image,
                $absolute
            );
        }

        $size = $this->keepAspectRatio(
            $image,
            $processingInstructions[ 'width'] ?: $processingInstructions[ 'maxWidth'] ?: $processingInstructions[ 'minWidth'],
            $processingInstructions[ 'height'] ?: $processingInstructions[ 'maxHeight'] ?: $processingInstructions[ 'mimHeight']
        );

        /**
         * js processing will only work if the url is generated by a TagViewHelper
         */
        $cldresponsive = 0;
        if ($this->processViaJavascript()) {
            if ($processingInstructions['height']) {
            } elseif ($image->getProperty('width')==$size['width']) {
                $cldresponsive = 1;
            } elseif ($image->getProperty('height')==$size['height']) {
                $cldresponsive = 1;
            } elseif ($size['width']==NULL && $size['height']==NULL) {
                $cldresponsive = 1;
            }
        }

        $convertedInstructions = ($cldresponsive)
            ? Constants::CLOUDINARY_RESPONSIVE_DEFAULT
            : $size;

        /**
         * if the image has to be cropped
         */
        if (array_key_exists( 'crop', $processingInstructions) && $processingInstructions[ 'crop'] && $convertedInstructions['width']!='auto') {
            /**
             * we get the values (x, y, width and height in percentages) of the cropped area
             */
            $cropProperties = $processingInstructions[ 'crop'];

            /**
             * we assign them to each property of the $convertedInstructions array
             */
            $convertedInstructions['crop'] = 'crop';
            $convertedInstructions['x'] = (int)$cropProperties->getOffsetLeft();
            $convertedInstructions['y'] = (int)$cropProperties->getOffsetTop();
            $convertedInstructions['width'] = (int)$cropProperties->getWidth();
            $convertedInstructions['height'] = (int)$cropProperties->getHeight();
        }

        if ($this->getFormat()) {
            $format = ',f_' . $this->getFormat();
            if ($convertedInstructions['crop']) {
                $convertedInstructions['crop'] .= $format;
            } else if ($convertedInstructions['x']) {
                $convertedInstructions['x'] .= $format;
            } else if ($convertedInstructions['y']) {
                $convertedInstructions['y'] .= $format;
            } else if ($convertedInstructions['width']) {
                $convertedInstructions['width'] .= $format;
            } else if ($convertedInstructions['height']) {
                $convertedInstructions['height'] .= $format;
            }
        }

        $url = cloudinary_url(
            $image->getProperty( Constants::SYS_FILE_FIELD_PUBLIC_ID).'.'.$image->getExtension(),
            array_merge(
                [
                    'secure' => true
                ],
                $convertedInstructions
            )
        );

        # add modification timestamp of local file to the cloudinary URL to burst the cache.
        if ($modificationDate = $image->getProperty('modification_date')) {
            $url .= (parse_url($url, PHP_URL_QUERY) ? '&' : '?').'t='.$modificationDate;
        }

        return $url;
    }

    private function keepAspectRatio( FileInterface $image, $width, $height) : array {
        $originalAspectRatio = $image->getProperty( 'width') / $image->getProperty( 'height');

        if( !$width && !$height) {

            list( $width, $height) = [
                $image->getProperty( 'width'),
                $image->getProperty( 'height')
            ];

        } else if ( !$width) {

            $width = $height * $image->getProperty( 'width') / $image->getProperty( 'height');

        } else if ( !$height) {

            $height = $width * $image->getProperty( 'height') / $image->getProperty( 'width');

        }

        return [
            'width' => (int)( $width && $originalAspectRatio >= 1 ? $width : ( $height * $image->getProperty( 'width') / $image->getProperty( 'height'))),
            'height' => (int)( $height && $originalAspectRatio <= 1 ? $height : ( $width * $image->getProperty( 'height') / $image->getProperty( 'width'))),
        ];
    }

    private function canDeliverViaCloudinary( $image, array $processingInstructions) : bool {
        return !!$image->getProperty( Constants::SYS_FILE_FIELD_PUBLIC_ID)
            &&  !$image->getProperty( Constants::SYS_FILE_FIELD_FAILED)
            &&  ( !array_key_exists( 'cropVariant', $processingInstructions) || !$processingInstructions[ 'cropVariant']) ;
    }

}
